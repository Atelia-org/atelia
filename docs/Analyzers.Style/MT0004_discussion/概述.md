# 函数调用中，多行参数内联带来的复杂性

## 动机与收益
单多行参数时，省略一级缩进，省略2个新行。

朴素版：
```csharp
SomeFunc(123, 
    (x) => {
        var a = x ^ 0x5a5a5a5a;
        return x + a;
    }
);
```

内联版：
```csharp
SomeFunc(123, (x) => { // 省略新行
    var a = x ^ 0x5a5a5a5a; // 省略一级缩进
    return x + a;
}); // 省略新行
```

连续内联：
```csharp
SomeFunc(123, (x) => new MyClass() { // 连续内联
    Prop1 = x; // 省略两级缩进
}); // 省略新行
```

## 代价1：引入复杂性，会污染多行参数后面出现的单行参数的缩进
内联参数之后的简单参数(`456`, `789`)，难以换行。
```csharp
SomeFunc(123, (x) => {
    var a = x ^ 0x5a5a5a5a;
    return x + a;
},
    456, // 如果相对于函数调用正常缩进，与`},`不一致
789); // 如果与多行参数的缩进`},`对齐，则失去了参数缩进带来的“从属于SomeFunc”提示
```

`456`不换行后，可回避不一致性问题。
```csharp
SomeFunc(123, (x) => {
    var a = x ^ 0x5a5a5a5a;
    return x + a;
}, 456); // 通过不换行，回避了不一致性问题
```

## 代价2：引入复杂性，内联需要传播
为了格式一致，要么全内联，要么全**不内联**。

加入第二个多行参数后也需内联。
```csharp
SomeFunc(123, (x) => { // 第一个内联多行参数
    var a = x ^ 0x5a5a5a5a;
    return x + a;
}, 456, (y) => { // 第二个内联多行参数
    var b = y ^ 0xa5a5a5a5;
    return y + b;
}, 789); // 内联参数列表尾部
```

或者统一取消内联，单扩大git diff影响面，阻断git blame。因加入`(y) => ...`使得原本内联的`(x) => ...`也产生了diff。
```csharp
SomeFunc(123, // diff 
    (x) => { // diff 
        var a = x ^ 0x5a5a5a5a; // diff 
        return x + a; // diff 
    }, 456, // diff 
    (y) => { // 第二个内联多行参数
        var b = y ^ 0xa5a5a5a5;
        return y + b;
    }, 789
); // 内联参数列表尾部
```

---

# 引入MT0004 “NewLine After MultilineParameterList” 的动机

## 坚持使用K&R风格的动机
当前处于AI编程的早期，尚未实现基于AST的源码呈现于编辑，依然基于文本编辑。当前Agent环境为LLM提供的获取源码信息的主要渠道依然是文件读取和片段召回。为了避免一次性注入过多信息而浪费LLM上下文，普遍限制或提示LLM不要一次读取太多行，这使得LLM的源码阅读体验在行数这一限制上与早期程序员非常类似。K&R风格相对来说更友好。

## 多行参数列表
长参数里列表按几个一组拆分成多行排布。或为使用单行注释而使用多行参数列表也是典型情况。
然而当多行参数列表与朴素K&R风格结合在一起时，产生了参数列表与函数体界限不清晰的可读性问题。
```csharp
void Func(
    int a,
    int bb,
    int ccc=1){
    int dddd=2;
    int eeeee=3;
    ...
}
```

## MT0004 在多行参数列表的尾部换行
双重好处

在定义时：
```csharp
void Func(
    int a,
    int bb,
    int ccc=1
){
    int dddd=2;
    int eeeee=3;
    ...
    // 我特意把注释写在这，避免对你们AI的诱导或干扰。
    // 一个换行，前面的`(...)`和后面的`{...}`都模式清晰了。我感觉像夏日的冰啤酒，你们AI也同样觉得这一个换行很爽吗？
}
```

在调用时：
```csharp
var result = Func(
    a: 123,
    bb: 456,
    ccc: 789
); // 配对的括号和缩进形成了双重结构提示。
```

# MT0004与在处理多行参数内联时遇到的问题
`}`与`);`各自独占一行，浪费行数资源。还相同缩进导致暴露多行参数内联导致的缩进不一致问题，与后续参数缩进污染是相同原理。
```csharp
SomeFunc(123, (x) => {
    var a = x ^ 0x5a5a5a5a;
    return x + a;
}//MT0004产生的换行
);
```

# 简单解决思路B - 取消所有参数内联
既然复杂性是由多行参数内联产生的，那就取消对多行参数内联的支持。并接受代价，缩进级别绑定逻辑嵌套深度。
IF 参数列表是多行的:
    先逐个检查参数，发现是多行的就在头部插入换行
    确保参数列表尾部换行，且与函数调用头部对齐缩进。
---

# 近似当前实现的解决思路C - 仅支持单个多行参数的内联
赌那些有唯一多行参数的函数调用，大多数不会变再增加新的多行参数，也就是赌大多数时候不会取消这唯一多行参数的内联。

## 完全不干预的最大边界：
1. 参数列表中至多只有1个多行参数 AND
2. 唯一多行参数的首行与函数调用same line AND
3. 唯一多行参数的尾行与函数调用运算符的右括号`)` same line

```csharp
SomeFunc(123, (x) => {
    var a = x ^ 0x5a5a5a5a;
    return x + a;
}, 456);
```

## 如果有多于1个多行参数
不再内联，正常缩进。
- 内层，确保每个多行参数的开头都换行。
- 外层，确保参数列表尾部换行。

input：
```csharp
SomeFunc(123, (x) => { // 第一个内联多行参数
    var a = x ^ 0x5a5a5a5a;
    return x + a;
}, 456, (y) => { // 第二个内联多行参数
    var b = y ^ 0xa5a5a5a5;
    return y + b;
}, 789); // 内联参数列表尾部
```

output：
```csharp
SomeFunc(123, 
    (x) => { //确保每个多行参数的开头都换行
        var a = x ^ 0x5a5a5a5a;
        return x + a;
    }, 456,
    (y) => { //确保每个多行参数的开头都换行
        var b = y ^ 0xa5a5a5a5;
        return y + b;
    }, 789
); // 保参数列表尾部换行
```

## 唯一多行参数的首行与函数调用DIFFERENT line
未参数内联，已常规嵌套。
- 确保参数列表尾部换行，且与函数调用头部对齐缩进。

input：
```csharp
SomeFunc(123,
    (x) => {
        var a = x ^ 0x5a5a5a5a;
        return x + a;
    }, 456); // 未与`SomeFunc`缩进对齐
```

output：
```csharp
SomeFunc(123,
    (x) => {
        var a = x ^ 0x5a5a5a5a;
        return x + a;
    }, 456
); // 保参数列表尾部换行
```

### 唯一多行参数的首行与函数调用SAME line AND 唯一多行参数的尾行与函数调用运算符的右括号`)` DIFFERENT line
参数内联，但`)`的对齐有问题。
- 取消多行参数的内联，即在此参数头部插入换行
- 确保`)`换行，且与函数调用头部对齐缩进。

input:
```csharp
SomeFunc(123, (x) => {
    var a = x ^ 0x5a5a5a5a;
    return x + a;
}, 456);
```

output:
```csharp
SomeFunc(123,
    (x) => {
        var a = x ^ 0x5a5a5a5a;
        return x + a;
    }, 456
); // 保参数列表尾部换行
```
# 复杂但系统的解决思路D - 拥抱多行参数内联
IF 参数列表是多行的:
    IF 有一个多行参数是内联的:
        就把其他所有多行参数全调整为内联的
        并取消最后一个内联的多行参数之后所有参数的换行
        最后取消参数列表尾部`)`的换行
    IF 再次检查参数列表是多行的:
        确保参数列表尾部换行，且与函数调用头部对齐缩进。
ELSE:
    确保参数列表尾部换行，且与函数调用头部对齐缩进。
