diff --git a/src/MemoTree.Cli/Commands/ConnectCommand.cs b/src/MemoTree.Cli/Commands/ConnectCommand.cs
index a94a939..c041802 100644
--- a/src/MemoTree.Cli/Commands/ConnectCommand.cs
+++ b/src/MemoTree.Cli/Commands/ConnectCommand.cs
@@ -17,14 +17,15 @@ namespace MemoTree.Cli.Commands {
                 targetPathArgument
  };
 
-            command.SetHandler(async (string targetPath) => {
-                try {
-                    await ExecuteAsync(targetPath);
-                } catch (Exception ex) {
-                    Console.WriteLine($"Error: {ex.Message}");
-                    Environment.Exit(1);
-                }
-            }, targetPathArgument
+            command.SetHandler(
+                async (string targetPath) => {
+                    try {
+                        await ExecuteAsync(targetPath);
+                    } catch (Exception ex) {
+                        Console.WriteLine($"Error: {ex.Message}");
+                        Environment.Exit(1);
+                    }
+                }, targetPathArgument
             );
 
             return command;
diff --git a/src/MemoTree.Cli/Commands/CreateCommand.cs b/src/MemoTree.Cli/Commands/CreateCommand.cs
index bb62ad7..2cb5624 100644
--- a/src/MemoTree.Cli/Commands/CreateCommand.cs
+++ b/src/MemoTree.Cli/Commands/CreateCommand.cs
@@ -26,80 +26,81 @@ public static class CreateCommand {
             contentOption
  };
 
-        command.SetHandler(async (string title, string? parentIdStr, string typeStr, bool openEditor) => {
-            try {
-                var workspaceManager = new WorkspaceManager();
-                var workspaceRoot = workspaceManager.FindWorkspaceRoot();
-
-                if (workspaceRoot == null) {
-                    Console.Error.WriteLine("Error: Not in a MemoTree workspace. Run 'memotree init' first.");
-                    Environment.Exit(1);
-                    return;
-                }
-
-                // 解析节点类型
-                if (!Enum.TryParse<NodeType>(typeStr, true, out var nodeType)) {
-                    Console.Error.WriteLine($"Error: Invalid node type '{typeStr}'. Valid types: concept, entity, process, attribute");
-                    Environment.Exit(1);
-                    return;
-                }
+        command.SetHandler(
+            async (string title, string? parentIdStr, string typeStr, bool openEditor) => {
+                try {
+                    var workspaceManager = new WorkspaceManager();
+                    var workspaceRoot = workspaceManager.FindWorkspaceRoot();
+
+                    if (workspaceRoot == null) {
+                        Console.Error.WriteLine("Error: Not in a MemoTree workspace. Run 'memotree init' first.");
+                        Environment.Exit(1);
+                        return;
+                    }
 
-                // 解析父节点ID
-                NodeId? parentId = null;
-                if (!string.IsNullOrEmpty(parentIdStr)) {
-                    try {
-                        parentId = NodeId.FromString(parentIdStr);
-                    } catch {
-                        Console.Error.WriteLine($"Error: Invalid parent node ID '{parentIdStr}'");
+                    // 解析节点类型
+                    if (!Enum.TryParse<NodeType>(typeStr, true, out var nodeType)) {
+                        Console.Error.WriteLine($"Error: Invalid node type '{typeStr}'. Valid types: concept, entity, process, attribute");
                         Environment.Exit(1);
                         return;
                     }
-                }
 
-                // 获取内容
-                string content = "";
-                if (openEditor) {
-                    content = await GetContentFromEditorAsync();
-                } else {
-                    // 检查是否有管道输入
-                    if (!Console.IsInputRedirected) {
-                        Console.WriteLine("Enter content (press Ctrl+D or Ctrl+Z to finish):");
+                    // 解析父节点ID
+                    NodeId? parentId = null;
+                    if (!string.IsNullOrEmpty(parentIdStr)) {
+                        try {
+                            parentId = NodeId.FromString(parentIdStr);
+                        } catch {
+                            Console.Error.WriteLine($"Error: Invalid parent node ID '{parentIdStr}'");
+                            Environment.Exit(1);
+                            return;
+                        }
                     }
 
-                    var lines = new List<string>();
-                    string? line;
-                    while ((line = Console.ReadLine()) != null) {
-                        lines.Add(line);
+                    // 获取内容
+                    string content = "";
+                    if (openEditor) {
+                        content = await GetContentFromEditorAsync();
+                    } else {
+                        // 检查是否有管道输入
+                        if (!Console.IsInputRedirected) {
+                            Console.WriteLine("Enter content (press Ctrl+D or Ctrl+Z to finish):");
+                        }
+
+                        var lines = new List<string>();
+                        string? line;
+                        while ((line = Console.ReadLine()) != null) {
+                            lines.Add(line);
+                        }
+                        content = string.Join(Environment.NewLine, lines);
                     }
-                    content = string.Join(Environment.NewLine, lines);
-                }
 
-                // 构建服务并创建节点
-                var services = new ServiceCollection();
-                services.AddLogging(b => b.AddConsole());
-                services.AddMemoTreeServices(workspaceRoot);
-                var provider = services.BuildServiceProvider();
+                    // 构建服务并创建节点
+                    var services = new ServiceCollection();
+                    services.AddLogging(b => b.AddConsole());
+                    services.AddMemoTreeServices(workspaceRoot);
+                    var provider = services.BuildServiceProvider();
 
-                var editor = provider.GetRequiredService<IMemoTreeEditor>();
-                var nodeId = await editor.CreateNodeAsync(title, content, parentId, nodeType);
+                    var editor = provider.GetRequiredService<IMemoTreeEditor>();
+                    var nodeId = await editor.CreateNodeAsync(title, content, parentId, nodeType);
 
-                Console.WriteLine($"Created node: {nodeId}");
-                Console.WriteLine($"Title: {title}");
-                Console.WriteLine($"Type: {nodeType}");
-                if (!string.IsNullOrEmpty(content)) {
-                    Console.WriteLine($"Content: {content.Length} characters");
-                }
+                    Console.WriteLine($"Created node: {nodeId}");
+                    Console.WriteLine($"Title: {title}");
+                    Console.WriteLine($"Type: {nodeType}");
+                    if (!string.IsNullOrEmpty(content)) {
+                        Console.WriteLine($"Content: {content.Length} characters");
+                    }
 
-                // 创建后默认渲染一次
-                var svc = provider.GetRequiredService<IMemoTreeService>();
-                var output = await svc.RenderViewAsync("default");
-                Console.WriteLine();
-                Console.WriteLine(output);
-            } catch (Exception ex) {
-                Console.Error.WriteLine($"Error: {ex.Message}");
-                Environment.Exit(1);
-            }
-        }, titleArgument, parentOption, typeOption, contentOption
+                    // 创建后默认渲染一次
+                    var svc = provider.GetRequiredService<IMemoTreeService>();
+                    var output = await svc.RenderViewAsync("default");
+                    Console.WriteLine();
+                    Console.WriteLine(output);
+                } catch (Exception ex) {
+                    Console.Error.WriteLine($"Error: {ex.Message}");
+                    Environment.Exit(1);
+                }
+            }, titleArgument, parentOption, typeOption, contentOption
         );
 
         return command;
@@ -115,11 +116,13 @@ public static class CreateCommand {
             (OperatingSystem.IsWindows() ? "notepad" : "nano");
 
             // 启动编辑器
-            var process = System.Diagnostics.Process.Start(new System.Diagnostics.ProcessStartInfo {
-                FileName = editor,
-                Arguments = tempFile,
-                UseShellExecute = true
-            });
+            var process = System.Diagnostics.Process.Start(
+                new System.Diagnostics.ProcessStartInfo {
+                    FileName = editor,
+                    Arguments = tempFile,
+                    UseShellExecute = true
+                }
+            );
 
             if (process != null) {
                 await process.WaitForExitAsync();
diff --git a/src/MemoTree.Cli/Commands/InitCommand.cs b/src/MemoTree.Cli/Commands/InitCommand.cs
index 8de32de..4d8843d 100644
--- a/src/MemoTree.Cli/Commands/InitCommand.cs
+++ b/src/MemoTree.Cli/Commands/InitCommand.cs
@@ -11,30 +11,32 @@ public static class InitCommand {
     public static Command Create() {
         var command = new Command("init", "Initialize a new MemoTree workspace in the current directory");
 
-        command.SetHandler(async () => {
-            try {
-                var workspaceManager = new WorkspaceManager();
-                var currentDir = Directory.GetCurrentDirectory();
+        command.SetHandler(
+            async () => {
+                try {
+                    var workspaceManager = new WorkspaceManager();
+                    var currentDir = Directory.GetCurrentDirectory();
 
-                // 检查是否已经是工作空间
-                if (workspaceManager.IsWorkspace()) {
-                    Console.WriteLine($"MemoTree workspace already exists in {currentDir}");
-                    return;
-                }
+                    // 检查是否已经是工作空间
+                    if (workspaceManager.IsWorkspace()) {
+                        Console.WriteLine($"MemoTree workspace already exists in {currentDir}");
+                        return;
+                    }
 
-                // 初始化工作空间
-                var workspaceRoot = await workspaceManager.InitializeWorkspaceAsync();
+                    // 初始化工作空间
+                    var workspaceRoot = await workspaceManager.InitializeWorkspaceAsync();
 
-                Console.WriteLine($"Initialized empty MemoTree workspace in {workspaceRoot}");
-                Console.WriteLine();
-                Console.WriteLine("Next steps:");
-                Console.WriteLine("  memotree create \"My First Node\"  # Create your first node");
-                Console.WriteLine("  memotree                          # View the tree structure");
-            } catch (Exception ex) {
-                Console.Error.WriteLine($"Error: {ex.Message}");
-                Environment.Exit(1);
+                    Console.WriteLine($"Initialized empty MemoTree workspace in {workspaceRoot}");
+                    Console.WriteLine();
+                    Console.WriteLine("Next steps:");
+                    Console.WriteLine("  memotree create \"My First Node\"  # Create your first node");
+                    Console.WriteLine("  memotree                          # View the tree structure");
+                } catch (Exception ex) {
+                    Console.Error.WriteLine($"Error: {ex.Message}");
+                    Environment.Exit(1);
+                }
             }
-        });
+        );
 
         return command;
     }
diff --git a/src/MemoTree.Cli/Commands/IntegrityCommands.cs b/src/MemoTree.Cli/Commands/IntegrityCommands.cs
index 7732100..27ca7c9 100644
--- a/src/MemoTree.Cli/Commands/IntegrityCommands.cs
+++ b/src/MemoTree.Cli/Commands/IntegrityCommands.cs
@@ -21,62 +21,65 @@ public static class IntegrityCommands {
         var jsonOpt = new Option<bool>("--json", () => false, description: "Output result as JSON");
         var cmd = new Command("validate", "Validate storage integrity and print a report") { jsonOpt };
 
-        cmd.SetHandler(async (bool json) => {
-            try {
-                var workspaceManager = new WorkspaceManager();
-                var root = workspaceManager.FindWorkspaceRoot();
-                if (root == null) {
-                    Console.Error.WriteLine("Error: Not in a MemoTree workspace. Run 'memotree init' first.");
-                    Environment.Exit(1);
-                    return;
-                }
+        cmd.SetHandler(
+            async (bool json) => {
+                try {
+                    var workspaceManager = new WorkspaceManager();
+                    var root = workspaceManager.FindWorkspaceRoot();
+                    if (root == null) {
+                        Console.Error.WriteLine("Error: Not in a MemoTree workspace. Run 'memotree init' first.");
+                        Environment.Exit(1);
+                        return;
+                    }
 
-                var services = new ServiceCollection();
-                services.AddLogging(b => b.AddConsole());
-                services.AddMemoTreeServices(root);
-                var provider = services.BuildServiceProvider();
+                    var services = new ServiceCollection();
+                    services.AddLogging(b => b.AddConsole());
+                    services.AddMemoTreeServices(root);
+                    var provider = services.BuildServiceProvider();
 
-                var storage = provider.GetRequiredService<ICognitiveNodeStorage>();
-                var result = await storage.ValidateIntegrityAsync();
+                    var storage = provider.GetRequiredService<ICognitiveNodeStorage>();
+                    var result = await storage.ValidateIntegrityAsync();
 
-                if (json) {
-                    var payload = new {
-                        validatedAt = result.ValidatedAt,
-                        isValid = result.IsValid,
-                        warnings = result.Warnings,
-                        errors = result.Errors
-                    };
-                    var text = System.Text.Json.JsonSerializer.Serialize(payload, new System.Text.Json.JsonSerializerOptions {
-                        WriteIndented = true
-                    });
-                    Console.WriteLine(text);
-                } else {
-                    Console.WriteLine($"Integrity validation at {result.ValidatedAt:u}");
-                    Console.WriteLine(result.IsValid ? "Status: OK" : "Status: ISSUES FOUND");
+                    if (json) {
+                        var payload = new {
+                            validatedAt = result.ValidatedAt,
+                            isValid = result.IsValid,
+                            warnings = result.Warnings,
+                            errors = result.Errors
+                        };
+                        var text = System.Text.Json.JsonSerializer.Serialize(
+                            payload, new System.Text.Json.JsonSerializerOptions {
+                                WriteIndented = true
+                            }
+                        );
+                        Console.WriteLine(text);
+                    } else {
+                        Console.WriteLine($"Integrity validation at {result.ValidatedAt:u}");
+                        Console.WriteLine(result.IsValid ? "Status: OK" : "Status: ISSUES FOUND");
 
-                    if (result.Warnings.Count > 0) {
-                        Console.WriteLine();
-                        Console.WriteLine($"Warnings ({result.Warnings.Count}):");
-                        foreach (var w in result.Warnings) {
-                            Console.WriteLine($"  - {w}");
+                        if (result.Warnings.Count > 0) {
+                            Console.WriteLine();
+                            Console.WriteLine($"Warnings ({result.Warnings.Count}):");
+                            foreach (var w in result.Warnings) {
+                                Console.WriteLine($"  - {w}");
+                            }
                         }
-                    }
 
-                    if (result.Errors.Count > 0) {
-                        Console.WriteLine();
-                        Console.WriteLine($"Errors ({result.Errors.Count}):");
-                        foreach (var e in result.Errors) {
-                            Console.WriteLine($"  - {e}");
+                        if (result.Errors.Count > 0) {
+                            Console.WriteLine();
+                            Console.WriteLine($"Errors ({result.Errors.Count}):");
+                            foreach (var e in result.Errors) {
+                                Console.WriteLine($"  - {e}");
+                            }
                         }
                     }
-                }
 
-                Environment.ExitCode = result.IsValid ? 0 : 2;
-            } catch (Exception ex) {
-                Console.Error.WriteLine($"Error: {ex.Message}");
-                Environment.Exit(1);
-            }
-        }, jsonOpt
+                    Environment.ExitCode = result.IsValid ? 0 : 2;
+                } catch (Exception ex) {
+                    Console.Error.WriteLine($"Error: {ex.Message}");
+                    Environment.Exit(1);
+                }
+            }, jsonOpt
         );
 
         return cmd;
@@ -85,11 +88,12 @@ public static class IntegrityCommands {
     public static Command CreateRepairCommand() {
         var dryRun = new Option<bool>("--dry-run", () => true, "Show planned fixes without changing files");
         var cmd = new Command("repair", "Scan and propose repairs for common integrity issues (preview)") { dryRun };
-        cmd.SetHandler(async (bool _dryRun) => {
-            Console.WriteLine("Repair is not implemented yet. Use 'integrity validate --json' to inspect issues.");
-            Environment.ExitCode = 3;
-            await Task.CompletedTask;
-        }, dryRun
+        cmd.SetHandler(
+            async (bool _dryRun) => {
+                Console.WriteLine("Repair is not implemented yet. Use 'integrity validate --json' to inspect issues.");
+                Environment.ExitCode = 3;
+                await Task.CompletedTask;
+            }, dryRun
         );
         return cmd;
     }
diff --git a/src/MemoTree.Cli/Commands/ViewCommands.cs b/src/MemoTree.Cli/Commands/ViewCommands.cs
index 8bfdbc8..3555cc8 100644
--- a/src/MemoTree.Cli/Commands/ViewCommands.cs
+++ b/src/MemoTree.Cli/Commands/ViewCommands.cs
@@ -12,30 +12,31 @@ public static class ViewCommands {
         var idArg = new Argument<string>("id", "Node ID to expand");
         var cmd = new Command("expand", "Expand a node in the current view") { idArg };
 
-        cmd.SetHandler(async (string id) => {
-            try {
-                var workspaceManager = new WorkspaceManager();
-                var root = workspaceManager.FindWorkspaceRoot();
-                if (root == null) {
-                    Console.Error.WriteLine("Error: Not in a MemoTree workspace. Run 'memotree init' first.");
+        cmd.SetHandler(
+            async (string id) => {
+                try {
+                    var workspaceManager = new WorkspaceManager();
+                    var root = workspaceManager.FindWorkspaceRoot();
+                    if (root == null) {
+                        Console.Error.WriteLine("Error: Not in a MemoTree workspace. Run 'memotree init' first.");
+                        Environment.Exit(1);
+                        return;
+                    }
+                    var nodeId = NodeId.FromString(id);
+                    var services = new ServiceCollection();
+                    services.AddLogging(b => b.AddConsole());
+                    services.AddMemoTreeServices(root);
+                    var provider = services.BuildServiceProvider();
+                    var svc = provider.GetRequiredService<IMemoTreeService>();
+
+                    await svc.ExpandNodeAsync(nodeId, "default");
+                    var output = await svc.RenderViewAsync("default");
+                    Console.WriteLine(output);
+                } catch (Exception ex) {
+                    Console.Error.WriteLine($"Error: {ex.Message}");
                     Environment.Exit(1);
-                    return;
                 }
-                var nodeId = NodeId.FromString(id);
-                var services = new ServiceCollection();
-                services.AddLogging(b => b.AddConsole());
-                services.AddMemoTreeServices(root);
-                var provider = services.BuildServiceProvider();
-                var svc = provider.GetRequiredService<IMemoTreeService>();
-
-                await svc.ExpandNodeAsync(nodeId, "default");
-                var output = await svc.RenderViewAsync("default");
-                Console.WriteLine(output);
-            } catch (Exception ex) {
-                Console.Error.WriteLine($"Error: {ex.Message}");
-                Environment.Exit(1);
-            }
-        }, idArg
+            }, idArg
         );
 
         return cmd;
@@ -45,30 +46,31 @@ public static class ViewCommands {
         var idArg = new Argument<string>("id", "Node ID to collapse");
         var cmd = new Command("collapse", "Collapse a node in the current view") { idArg };
 
-        cmd.SetHandler(async (string id) => {
-            try {
-                var workspaceManager = new WorkspaceManager();
-                var root = workspaceManager.FindWorkspaceRoot();
-                if (root == null) {
-                    Console.Error.WriteLine("Error: Not in a MemoTree workspace. Run 'memotree init' first.");
+        cmd.SetHandler(
+            async (string id) => {
+                try {
+                    var workspaceManager = new WorkspaceManager();
+                    var root = workspaceManager.FindWorkspaceRoot();
+                    if (root == null) {
+                        Console.Error.WriteLine("Error: Not in a MemoTree workspace. Run 'memotree init' first.");
+                        Environment.Exit(1);
+                        return;
+                    }
+                    var nodeId = NodeId.FromString(id);
+                    var services = new ServiceCollection();
+                    services.AddLogging(b => b.AddConsole());
+                    services.AddMemoTreeServices(root);
+                    var provider = services.BuildServiceProvider();
+                    var svc = provider.GetRequiredService<IMemoTreeService>();
+
+                    await svc.CollapseNodeAsync(nodeId, "default");
+                    var output = await svc.RenderViewAsync("default");
+                    Console.WriteLine(output);
+                } catch (Exception ex) {
+                    Console.Error.WriteLine($"Error: {ex.Message}");
                     Environment.Exit(1);
-                    return;
                 }
-                var nodeId = NodeId.FromString(id);
-                var services = new ServiceCollection();
-                services.AddLogging(b => b.AddConsole());
-                services.AddMemoTreeServices(root);
-                var provider = services.BuildServiceProvider();
-                var svc = provider.GetRequiredService<IMemoTreeService>();
-
-                await svc.CollapseNodeAsync(nodeId, "default");
-                var output = await svc.RenderViewAsync("default");
-                Console.WriteLine(output);
-            } catch (Exception ex) {
-                Console.Error.WriteLine($"Error: {ex.Message}");
-                Environment.Exit(1);
-            }
-        }, idArg
+            }, idArg
         );
 
         return cmd;
@@ -79,29 +81,30 @@ public static class ViewCommands {
         var descOpt = new Option<string?>(new[] { "--description", "-d" }, () => null, "Optional description for the view");
         var cmd = new Command("create", "Create a new view") { nameArg, descOpt };
 
-        cmd.SetHandler(async (string name, string? description) => {
-            try {
-                var workspaceManager = new WorkspaceManager();
-                var root = workspaceManager.FindWorkspaceRoot();
-                if (root == null) {
-                    Console.Error.WriteLine("Error: Not in a MemoTree workspace. Run 'memotree init' first.");
+        cmd.SetHandler(
+            async (string name, string? description) => {
+                try {
+                    var workspaceManager = new WorkspaceManager();
+                    var root = workspaceManager.FindWorkspaceRoot();
+                    if (root == null) {
+                        Console.Error.WriteLine("Error: Not in a MemoTree workspace. Run 'memotree init' first.");
+                        Environment.Exit(1);
+                        return;
+                    }
+                    var services = new ServiceCollection();
+                    services.AddLogging(b => b.AddConsole());
+                    services.AddMemoTreeServices(root);
+                    var provider = services.BuildServiceProvider();
+                    var svc = provider.GetRequiredService<IMemoTreeService>();
+
+                    await svc.CreateViewAsync(name, description);
+                    var output = await svc.RenderViewAsync(name);
+                    Console.WriteLine(output);
+                } catch (Exception ex) {
+                    Console.Error.WriteLine($"Error: {ex.Message}");
                     Environment.Exit(1);
-                    return;
                 }
-                var services = new ServiceCollection();
-                services.AddLogging(b => b.AddConsole());
-                services.AddMemoTreeServices(root);
-                var provider = services.BuildServiceProvider();
-                var svc = provider.GetRequiredService<IMemoTreeService>();
-
-                await svc.CreateViewAsync(name, description);
-                var output = await svc.RenderViewAsync(name);
-                Console.WriteLine(output);
-            } catch (Exception ex) {
-                Console.Error.WriteLine($"Error: {ex.Message}");
-                Environment.Exit(1);
-            }
-        }, nameArg, descOpt
+            }, nameArg, descOpt
         );
 
         return cmd;
@@ -112,29 +115,30 @@ public static class ViewCommands {
         var descArg = new Argument<string>("description", "New description");
         var cmd = new Command("set-description", "Update description of a view") { nameArg, descArg };
 
-        cmd.SetHandler(async (string name, string description) => {
-            try {
-                var workspaceManager = new WorkspaceManager();
-                var root = workspaceManager.FindWorkspaceRoot();
-                if (root == null) {
-                    Console.Error.WriteLine("Error: Not in a MemoTree workspace. Run 'memotree init' first.");
+        cmd.SetHandler(
+            async (string name, string description) => {
+                try {
+                    var workspaceManager = new WorkspaceManager();
+                    var root = workspaceManager.FindWorkspaceRoot();
+                    if (root == null) {
+                        Console.Error.WriteLine("Error: Not in a MemoTree workspace. Run 'memotree init' first.");
+                        Environment.Exit(1);
+                        return;
+                    }
+                    var services = new ServiceCollection();
+                    services.AddLogging(b => b.AddConsole());
+                    services.AddMemoTreeServices(root);
+                    var provider = services.BuildServiceProvider();
+                    var svc = provider.GetRequiredService<IMemoTreeService>();
+
+                    await svc.UpdateViewDescriptionAsync(name, description);
+                    var output = await svc.RenderViewAsync(name);
+                    Console.WriteLine(output);
+                } catch (Exception ex) {
+                    Console.Error.WriteLine($"Error: {ex.Message}");
                     Environment.Exit(1);
-                    return;
                 }
-                var services = new ServiceCollection();
-                services.AddLogging(b => b.AddConsole());
-                services.AddMemoTreeServices(root);
-                var provider = services.BuildServiceProvider();
-                var svc = provider.GetRequiredService<IMemoTreeService>();
-
-                await svc.UpdateViewDescriptionAsync(name, description);
-                var output = await svc.RenderViewAsync(name);
-                Console.WriteLine(output);
-            } catch (Exception ex) {
-                Console.Error.WriteLine($"Error: {ex.Message}");
-                Environment.Exit(1);
-            }
-        }, nameArg, descArg
+            }, nameArg, descArg
         );
 
         return cmd;
diff --git a/src/MemoTree.Core/Types/HierarchyInfo.cs b/src/MemoTree.Core/Types/HierarchyInfo.cs
index 276b767..cac1a20 100644
--- a/src/MemoTree.Core/Types/HierarchyInfo.cs
+++ b/src/MemoTree.Core/Types/HierarchyInfo.cs
@@ -104,18 +104,22 @@ namespace MemoTree.Core.Types {
 
             foreach (var childId in orderedChildIds) {
                 if (childDict.TryGetValue(childId, out var child)) {
-                    newChildren.Add(child with {
-                        Order = order++
-                    });
+                    newChildren.Add(
+                        child with {
+                            Order = order++
+                        }
+                    );
                 }
             }
 
             // 添加未在新顺序中指定的子节点
             foreach (var child in Children) {
                 if (!orderedChildIds.Contains(child.NodeId)) {
-                    newChildren.Add(child with {
-                        Order = order++
-                    });
+                    newChildren.Add(
+                        child with {
+                            Order = order++
+                        }
+                    );
                 }
             }
 
diff --git a/src/MemoTree.Core/Validation/DefaultBusinessRuleValidator.cs b/src/MemoTree.Core/Validation/DefaultBusinessRuleValidator.cs
index cf9b0b6..7be2d36 100644
--- a/src/MemoTree.Core/Validation/DefaultBusinessRuleValidator.cs
+++ b/src/MemoTree.Core/Validation/DefaultBusinessRuleValidator.cs
@@ -42,8 +42,11 @@ namespace MemoTree.Core.Validation {
             // 如果不是递归删除，需要检查是否有子节点
             if (!recursive) {
                 // 这里需要实际的子节点检查，暂时添加警告
-                builder.AddWarning(ValidationWarning.Create("CHILDREN_CHECK_SKIPPED",
-                    "Child nodes existence check requires storage access", "HasChildren"));
+                builder.AddWarning(
+                    ValidationWarning.Create("CHILDREN_CHECK_SKIPPED",
+                        "Child nodes existence check requires storage access", "HasChildren"
+                    )
+                );
             }
 
             return Task.FromResult(builder.Build());
@@ -69,8 +72,11 @@ namespace MemoTree.Core.Validation {
 
             // 循环引用检查需要存储层支持
             if (newParentId != null) {
-                builder.AddWarning(ValidationWarning.Create("CIRCULAR_REFERENCE_CHECK_SKIPPED",
-                    "Circular reference check requires storage access", "CircularReference"));
+                builder.AddWarning(
+                    ValidationWarning.Create("CIRCULAR_REFERENCE_CHECK_SKIPPED",
+                        "Circular reference check requires storage access", "CircularReference"
+                    )
+                );
             }
 
             return Task.FromResult(builder.Build());
@@ -91,8 +97,11 @@ namespace MemoTree.Core.Validation {
             );
 
             // 间接循环引用检查需要图遍历，需要存储层支持
-            builder.AddWarning(ValidationWarning.Create("INDIRECT_CIRCULAR_CHECK_SKIPPED",
-                "Indirect circular reference check requires graph traversal", "IndirectCircular"));
+            builder.AddWarning(
+                ValidationWarning.Create("INDIRECT_CIRCULAR_CHECK_SKIPPED",
+                    "Indirect circular reference check requires graph traversal", "IndirectCircular"
+                )
+            );
 
             return Task.FromResult(builder.Build());
         }
@@ -114,13 +123,19 @@ namespace MemoTree.Core.Validation {
             // 验证关系类型的合理性
             switch (relationType) {
                 case RelationType.InheritsFrom:
-                    builder.AddWarning(ValidationWarning.ForBestPractice(
-                        "Inheritance relations should be used carefully to maintain clear hierarchies"));
+                    builder.AddWarning(
+                        ValidationWarning.ForBestPractice(
+                            "Inheritance relations should be used carefully to maintain clear hierarchies"
+                        )
+                    );
                     break;
 
                 case RelationType.ComposedOf:
-                    builder.AddWarning(ValidationWarning.ForBestPractice(
-                        "Composition relations create strong coupling between nodes"));
+                    builder.AddWarning(
+                        ValidationWarning.ForBestPractice(
+                            "Composition relations create strong coupling between nodes"
+                        )
+                    );
                     break;
             }
 
@@ -136,8 +151,11 @@ namespace MemoTree.Core.Validation {
             .ForObjectId(nodeId.Value);
 
             // 深度检查需要遍历整个层次结构，需要存储层支持
-            builder.AddWarning(ValidationWarning.Create("DEPTH_CHECK_SKIPPED",
-                "Hierarchy depth check requires storage access", "Depth"));
+            builder.AddWarning(
+                ValidationWarning.Create("DEPTH_CHECK_SKIPPED",
+                    "Hierarchy depth check requires storage access", "Depth"
+                )
+            );
 
             return Task.FromResult(builder.Build());
         }
@@ -151,8 +169,11 @@ namespace MemoTree.Core.Validation {
             .ForObjectId(parentId.Value);
 
             // 子节点数量检查需要存储层支持
-            builder.AddWarning(ValidationWarning.Create("CHILDREN_COUNT_CHECK_SKIPPED",
-                "Children count check requires storage access", "ChildrenCount"));
+            builder.AddWarning(
+                ValidationWarning.Create("CHILDREN_COUNT_CHECK_SKIPPED",
+                    "Children count check requires storage access", "ChildrenCount"
+                )
+            );
 
             return Task.FromResult(builder.Build());
         }
@@ -190,12 +211,18 @@ namespace MemoTree.Core.Validation {
             };
 
             if (!isCompatible) {
-                builder.AddError(ValidationError.ForBusinessRule("IncompatibleNodeTypes",
-                    $"Node type {childType} is not compatible with parent type {parentType}"));
+                builder.AddError(
+                    ValidationError.ForBusinessRule("IncompatibleNodeTypes",
+                        $"Node type {childType} is not compatible with parent type {parentType}"
+                    )
+                );
             } else if ((parentType, childType) is not (NodeType.Container, _) and not (_, NodeType.Note)) {
                 // 对于非明确兼容的组合给出警告
-                builder.AddWarning(ValidationWarning.ForBestPractice(
-                    $"Consider the appropriateness of placing {childType} under {parentType}"));
+                builder.AddWarning(
+                    ValidationWarning.ForBestPractice(
+                        $"Consider the appropriateness of placing {childType} under {parentType}"
+                    )
+                );
             }
 
             return builder.Build();
@@ -231,8 +258,11 @@ namespace MemoTree.Core.Validation {
             };
 
             if (!isRecommended) {
-                builder.AddWarning(ValidationWarning.ForBestPractice(
-                    $"Relation {relationType} between {sourceType} and {targetType} may not be the most appropriate choice"));
+                builder.AddWarning(
+                    ValidationWarning.ForBestPractice(
+                        $"Relation {relationType} between {sourceType} and {targetType} may not be the most appropriate choice"
+                    )
+                );
             }
 
             return builder.Build();
@@ -247,8 +277,11 @@ namespace MemoTree.Core.Validation {
             .ForObjectId($"{sourceId}-{relationType}->{targetId}");
 
             // 重复关系检查需要存储层支持
-            builder.AddWarning(ValidationWarning.Create("DUPLICATE_CHECK_SKIPPED",
-                "Duplicate relation check requires storage access", "Duplicate"));
+            builder.AddWarning(
+                ValidationWarning.Create("DUPLICATE_CHECK_SKIPPED",
+                    "Duplicate relation check requires storage access", "Duplicate"
+                )
+            );
 
             return Task.FromResult(builder.Build());
         }
@@ -262,8 +295,11 @@ namespace MemoTree.Core.Validation {
             .ForObjectId($"{nodeId}-{operation}");
 
             // 权限检查需要安全上下文，MVP阶段跳过
-            builder.AddWarning(ValidationWarning.Create("PERMISSION_CHECK_SKIPPED",
-                "Permission check requires security context (MVP phase)", "Permission"));
+            builder.AddWarning(
+                ValidationWarning.Create("PERMISSION_CHECK_SKIPPED",
+                    "Permission check requires security context (MVP phase)", "Permission"
+                )
+            );
 
             return Task.FromResult(builder.Build());
         }
diff --git a/src/MemoTree.Core/Validation/DefaultConfigurationValidator.cs b/src/MemoTree.Core/Validation/DefaultConfigurationValidator.cs
index 1452282..1f06e75 100644
--- a/src/MemoTree.Core/Validation/DefaultConfigurationValidator.cs
+++ b/src/MemoTree.Core/Validation/DefaultConfigurationValidator.cs
@@ -16,9 +16,11 @@ namespace MemoTree.Core.Validation {
         /// </summary>
         public Task<ValidationResult> ValidateConfigurationAsync<T>(T configuration, CancellationToken cancellationToken = default) where T : class {
             if (configuration == null) {
-                return Task.FromResult(ValidationResult.Failure(
-                    ValidationError.ForRequired("Configuration")
-                ));
+                return Task.FromResult(
+                    ValidationResult.Failure(
+                        ValidationError.ForRequired("Configuration")
+                )
+                );
             }
 
             var builder = new ValidationResultBuilder()
@@ -181,9 +183,11 @@ namespace MemoTree.Core.Validation {
                     );
                 }
             } catch (Exception ex) {
-                builder.AddError(ValidationError.Create("INVALID_PATH",
-                    $"Invalid path format: {ex.Message}", configurationKey, path
-                ));
+                builder.AddError(
+                    ValidationError.Create("INVALID_PATH",
+                        $"Invalid path format: {ex.Message}", configurationKey, path
+                )
+                );
             }
 
             return builder.Build();
diff --git a/src/MemoTree.Services/MemoTreeService.cs b/src/MemoTree.Services/MemoTreeService.cs
index adea24b..2701d79 100644
--- a/src/MemoTree.Services/MemoTreeService.cs
+++ b/src/MemoTree.Services/MemoTreeService.cs
@@ -277,14 +277,16 @@ public class MemoTreeService : IMemoTreeService {
                 LastAccessTime = DateTime.UtcNow
             };
         } else {
-            list.Add(new VNodeState {
-                Id = id,
-                CurrentLevel = level,
-                IsExpanded = (level == LodLevel.Full),
-                IsVisible = true,
-                Order = 0,
-                LastAccessTime = DateTime.UtcNow
-            });
+            list.Add(
+                new VNodeState {
+                    Id = id,
+                    CurrentLevel = level,
+                    IsExpanded = (level == LodLevel.Full),
+                    IsVisible = true,
+                    Order = 0,
+                    LastAccessTime = DateTime.UtcNow
+                }
+            );
         }
         return state with {
             NodeStates = list,
diff --git a/src/MemoTree.Services/ServiceCollectionExtensions.cs b/src/MemoTree.Services/ServiceCollectionExtensions.cs
index d846c6e..1560e5f 100644
--- a/src/MemoTree.Services/ServiceCollectionExtensions.cs
+++ b/src/MemoTree.Services/ServiceCollectionExtensions.cs
@@ -29,23 +29,25 @@ public static class ServiceCollectionExtensions {
         services.AddSingleton<IWorkspacePathService, WorkspacePathService>();
 
         // 层次结构存储：使用CowNodeHierarchyStorage实现持久化
-        services.AddSingleton<INodeHierarchyStorage>(provider => {
-            var logger = provider.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CowNodeHierarchyStorage>>();
-            var pathService = provider.GetRequiredService<IWorkspacePathService>();
+        services.AddSingleton<INodeHierarchyStorage>(
+            provider => {
+                var logger = provider.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CowNodeHierarchyStorage>>();
+                var pathService = provider.GetRequiredService<IWorkspacePathService>();
 
-            // 通过路径服务获取层级关系持久化目录（自动处理链接工作空间）
-            var hierarchyDirectory = pathService.GetHierarchyDirectory();
+                // 通过路径服务获取层级关系持久化目录（自动处理链接工作空间）
+                var hierarchyDirectory = pathService.GetHierarchyDirectory();
 
-            // 创建版本化存储
-            var hierarchyStorageTask = VersionedStorageFactory.CreateHierarchyStorageAsync(
-                hierarchyDirectory,
-                provider.GetRequiredService<Microsoft.Extensions.Logging.ILogger<VersionedStorageImpl<NodeId, HierarchyInfo>>>()
-            );
+                // 创建版本化存储
+                var hierarchyStorageTask = VersionedStorageFactory.CreateHierarchyStorageAsync(
+                    hierarchyDirectory,
+                    provider.GetRequiredService<Microsoft.Extensions.Logging.ILogger<VersionedStorageImpl<NodeId, HierarchyInfo>>>()
+                );
 
-            var hierarchyStorage = hierarchyStorageTask.GetAwaiter().GetResult();
+                var hierarchyStorage = hierarchyStorageTask.GetAwaiter().GetResult();
 
-            return new CowNodeHierarchyStorage(hierarchyStorage, logger);
-        });
+                return new CowNodeHierarchyStorage(hierarchyStorage, logger);
+            }
+        );
 
         // 节点复合存储：MVP使用 SimpleCognitiveNodeStorage（Content/Metadata基于文件，Hierarchy通过上面的实现）
         services.AddSingleton<ICognitiveNodeStorage, SimpleCognitiveNodeStorage>();
@@ -68,47 +70,53 @@ public static class ServiceCollectionExtensions {
         string workspaceRoot
     ) {
         // 配置选项
-        services.Configure<MemoTreeOptions>(options => {
-            options.WorkspaceRoot = workspaceRoot;
-            options.CogNodesDirectory = "CogNodes";
-            options.RelationsDirectory = "Relations";
-            // ViewsDirectory 在MVP版本中暂时不需要
-            options.DefaultMaxContextTokens = 8000;
-            options.MaxMemoTreeViewTokens = 150000;
-            options.AutoSaveIntervalMinutes = 5;
-            options.EnableVersionControl = true;
-        });
-
-        services.Configure<StorageOptions>(options => {
-            options.MetadataFileName = "meta.yaml";
-            options.GistContentFileName = "gist.md";
-            options.SummaryContentFileName = "summary.md";
-            options.FullContentFileName = "full.md";
-            options.ExternalLinksFileName = "external-links.json";
-            options.HierarchyFileExtension = ".yaml";
-            options.RelationsFileName = "relations.yaml";
-            options.RelationTypesFileName = "relation-types.yaml";
-            options.HashAlgorithm = "SHA256";
-        });
+        services.Configure<MemoTreeOptions>(
+            options => {
+                options.WorkspaceRoot = workspaceRoot;
+                options.CogNodesDirectory = "CogNodes";
+                options.RelationsDirectory = "Relations";
+                // ViewsDirectory 在MVP版本中暂时不需要
+                options.DefaultMaxContextTokens = 8000;
+                options.MaxMemoTreeViewTokens = 150000;
+                options.AutoSaveIntervalMinutes = 5;
+                options.EnableVersionControl = true;
+            }
+        );
+
+        services.Configure<StorageOptions>(
+            options => {
+                options.MetadataFileName = "meta.yaml";
+                options.GistContentFileName = "gist.md";
+                options.SummaryContentFileName = "summary.md";
+                options.FullContentFileName = "full.md";
+                options.ExternalLinksFileName = "external-links.json";
+                options.HierarchyFileExtension = ".yaml";
+                options.RelationsFileName = "relations.yaml";
+                options.RelationTypesFileName = "relation-types.yaml";
+                options.HashAlgorithm = "SHA256";
+            }
+        );
 
         // 层次结构存储：使用CowNodeHierarchyStorage实现持久化
-        services.AddSingleton<INodeHierarchyStorage>(provider => {
-            var logger = provider.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CowNodeHierarchyStorage>>();
-            var pathService = provider.GetRequiredService<IWorkspacePathService>();
+        services.AddSingleton<INodeHierarchyStorage>(
+            provider => {
+                var logger = provider.GetRequiredService<Microsoft.Extensions.Logging.ILogger<CowNodeHierarchyStorage>>();
+                var pathService = provider.GetRequiredService<IWorkspacePathService>();
 
-            // 获取层次关系存储目录
-            var hierarchyDirectory = pathService.GetHierarchyDirectory();
+                // 获取层次关系存储目录
+                var hierarchyDirectory = pathService.GetHierarchyDirectory();
 
-            // 创建版本化存储
-            var hierarchyStorageTask = VersionedStorageFactory.CreateHierarchyStorageAsync(
-                hierarchyDirectory,
-                provider.GetRequiredService<Microsoft.Extensions.Logging.ILogger<VersionedStorageImpl<NodeId, HierarchyInfo>>>()
-            );
+                // 创建版本化存储
+                var hierarchyStorageTask = VersionedStorageFactory.CreateHierarchyStorageAsync(
+                    hierarchyDirectory,
+                    provider.GetRequiredService<Microsoft.Extensions.Logging.ILogger<VersionedStorageImpl<NodeId, HierarchyInfo>>>()
+                );
 
-            var hierarchyStorage = hierarchyStorageTask.GetAwaiter().GetResult();
+                var hierarchyStorage = hierarchyStorageTask.GetAwaiter().GetResult();
 
-            return new CowNodeHierarchyStorage(hierarchyStorage, logger);
-        });
+                return new CowNodeHierarchyStorage(hierarchyStorage, logger);
+            }
+        );
 
         // 路径管理服务
         services.AddSingleton<IWorkspacePathService, WorkspacePathService>();
diff --git a/src/MemoTree.Services/Storage/FileViewStateStorage.cs b/src/MemoTree.Services/Storage/FileViewStateStorage.cs
index f6f6b29..0b71a37 100644
--- a/src/MemoTree.Services/Storage/FileViewStateStorage.cs
+++ b/src/MemoTree.Services/Storage/FileViewStateStorage.cs
@@ -175,28 +175,32 @@ public class FileViewStateStorage : IViewStateStorage {
     public Task<ViewStorageStatistics> GetStatisticsAsync(CancellationToken cancellationToken = default) {
         var dir = _paths.GetViewsDirectory();
         if (!Directory.Exists(dir)) {
-            return Task.FromResult(new ViewStorageStatistics {
-                TotalViews = 0,
-                TotalSize = 0,
-                OldestView = DateTime.UtcNow,
-                NewestView = DateTime.UtcNow,
-                LargestView = null,
-                LargestViewSize = 0,
-                AverageViewSize = 0,
-            });
+            return Task.FromResult(
+                new ViewStorageStatistics {
+                    TotalViews = 0,
+                    TotalSize = 0,
+                    OldestView = DateTime.UtcNow,
+                    NewestView = DateTime.UtcNow,
+                    LargestView = null,
+                    LargestViewSize = 0,
+                    AverageViewSize = 0,
+                }
+            );
         }
 
         var files = Directory.GetFiles(dir, "*.json");
         if (files.Length == 0) {
-            return Task.FromResult(new ViewStorageStatistics {
-                TotalViews = 0,
-                TotalSize = 0,
-                OldestView = DateTime.UtcNow,
-                NewestView = DateTime.UtcNow,
-                LargestView = null,
-                LargestViewSize = 0,
-                AverageViewSize = 0,
-            });
+            return Task.FromResult(
+                new ViewStorageStatistics {
+                    TotalViews = 0,
+                    TotalSize = 0,
+                    OldestView = DateTime.UtcNow,
+                    NewestView = DateTime.UtcNow,
+                    LargestView = null,
+                    LargestViewSize = 0,
+                    AverageViewSize = 0,
+                }
+            );
         }
 
         long total = 0;
@@ -222,14 +226,16 @@ public class FileViewStateStorage : IViewStateStorage {
             }
         }
 
-        return Task.FromResult(new ViewStorageStatistics {
-            TotalViews = files.Length,
-            TotalSize = total,
-            OldestView = oldest,
-            NewestView = newest,
-            LargestView = largest,
-            LargestViewSize = maxSize,
-            AverageViewSize = files.Length > 0 ? (double)total / files.Length : 0,
-        });
+        return Task.FromResult(
+            new ViewStorageStatistics {
+                TotalViews = files.Length,
+                TotalSize = total,
+                OldestView = oldest,
+                NewestView = newest,
+                LargestView = largest,
+                LargestViewSize = maxSize,
+                AverageViewSize = files.Length > 0 ? (double)total / files.Length : 0,
+            }
+        );
     }
 }
diff --git a/tests/MemoTree.Tests/Analyzers/TestData/X0001_MultiScenario_Input.cs b/tests/MemoTree.Tests/Analyzers/TestData/X0001_MultiScenario_Input.cs
index ba3df45..5cf1c37 100644
--- a/tests/MemoTree.Tests/Analyzers/TestData/X0001_MultiScenario_Input.cs
+++ b/tests/MemoTree.Tests/Analyzers/TestData/X0001_MultiScenario_Input.cs
@@ -6,7 +6,8 @@ class X0001MultiScenarioSamples {
     // 1. Invocation
     void InvokeSamples() {
         Target(1,
-            2);
+            2
+        );
     }
 
     void Target(int a, int b) { }
@@ -14,32 +15,38 @@ class X0001MultiScenarioSamples {
     // 2. Object creation
     void ObjectCreation() {
         var obj = new Sample(10,
-            20);
+            20
+        );
     }
 
     record Sample(int A, int B);
 
     // 3. Method declaration
     void Decl(int a,
-        int b) { }
+        int b
+    ) { }
 
     // 4. Local function
     void Outer() {
         int Local(int x,
-            int y) => x + y;
+            int y
+        ) => x + y;
     }
 
     // 5. Delegate declaration
     delegate int D(int a,
-        int b);
+        int b
+    );
 
     // 6. Operator
     public static X0001MultiScenarioSamples operator +(X0001MultiScenarioSamples l,
-        X0001MultiScenarioSamples r) => l;
+        X0001MultiScenarioSamples r
+    ) => l;
 
     // 7. Record primary constructor (already above) + additional record example
     record R2(int X,
-        int Y);
+        int Y
+    );
 
     // 8. Parenthesized lambda
     void Lambda() {
diff --git a/tests/MemoTree.Tests/Analyzers/X0001MultiScenarioTests.cs b/tests/MemoTree.Tests/Analyzers/X0001MultiScenarioTests.cs
index 75fe9d9..0987824 100644
--- a/tests/MemoTree.Tests/Analyzers/X0001MultiScenarioTests.cs
+++ b/tests/MemoTree.Tests/Analyzers/X0001MultiScenarioTests.cs
@@ -17,17 +17,17 @@ public class X0001MultiScenarioTests {
     public void X0001_Reports_On_All_InlineFirst_Multiline_Constructs() {
         var code = LoadSource();
         var (diags, _) = AnalyzerTestHost.RunAnalyzer(code, "MemoTree.Analyzers.X0001OpenParenNewLineAnalyzer");
-    // Expect at least one diagnostic per applicable construct (8 scenarios after removing invalid conversion case)
-    Assert.True(diags.Count(d => d.Id == "X0001") >= 6);
+        // Expect at least one diagnostic per applicable construct (8 scenarios after removing invalid conversion case)
+        Assert.True(diags.Count(d => d.Id == "X0001") >= 6);
     }
 
     [Fact]
     public async Task X0001_CodeFix_Applies_To_First_Diagnostic_Iteratively() {
         var code = LoadSource();
-    var fixedText = await AnalyzerTestHost.ApplyAllCodeFixesAsync(code, "MemoTree.Analyzers.X0001OpenParenNewLineAnalyzer", new X0001OpenParenNewLineCodeFix(), "X0001");
+        var fixedText = await AnalyzerTestHost.ApplyAllCodeFixesAsync(code, "MemoTree.Analyzers.X0001OpenParenNewLineAnalyzer", new X0001OpenParenNewLineCodeFix(), "X0001");
         // After fixes, rerun analyzer should have zero diagnostics
         var (afterDiags, _) = AnalyzerTestHost.RunAnalyzer(fixedText, "MemoTree.Analyzers.X0001OpenParenNewLineAnalyzer");
-    Assert.DoesNotContain(afterDiags, d => d.Id == "X0001");
+        Assert.DoesNotContain(afterDiags, d => d.Id == "X0001");
     }
 }
 
@@ -38,7 +38,10 @@ internal static class TestContextHelper {
     private static string LocateRoot() {
         var dir = new DirectoryInfo(System.AppContext.BaseDirectory);
         for (int i = 0; i < 8 && dir != null; i++) {
-            if (File.Exists(Path.Combine(dir.FullName, "MemoTree.sln"))) return dir.FullName;
+            if (File.Exists(Path.Combine(dir.FullName, "MemoTree.sln"))) {
+                return dir.FullName;
+            }
+
             dir = dir.Parent!;
         }
         return System.AppContext.BaseDirectory; // fallback
diff --git a/tests/MemoTree.Tests/Json/NodeIdJsonConverterTests.cs b/tests/MemoTree.Tests/Json/NodeIdJsonConverterTests.cs
index 50cffed..f14fdcf 100644
--- a/tests/MemoTree.Tests/Json/NodeIdJsonConverterTests.cs
+++ b/tests/MemoTree.Tests/Json/NodeIdJsonConverterTests.cs
@@ -76,7 +76,8 @@ namespace MemoTree.Tests.Json {
             var json = "\"\"";
 
             // Act & Assert
-            Assert.Throws<JsonException>(() =>
+            Assert.Throws<JsonException>(
+                () =>
                 JsonSerializer.Deserialize<NodeId>(json, _jsonOptions)
             );
         }
@@ -87,7 +88,8 @@ namespace MemoTree.Tests.Json {
             var json = "{\"notValue\":\"test\"}";
 
             // Act & Assert
-            Assert.Throws<JsonException>(() =>
+            Assert.Throws<JsonException>(
+                () =>
                 JsonSerializer.Deserialize<NodeId>(json, _jsonOptions)
             );
         }
diff --git a/tests/MemoTree.Tests/Storage/Hierarchy/CowNodeHierarchyStorageTests.cs b/tests/MemoTree.Tests/Storage/Hierarchy/CowNodeHierarchyStorageTests.cs
index b3d541e..f124138 100644
--- a/tests/MemoTree.Tests/Storage/Hierarchy/CowNodeHierarchyStorageTests.cs
+++ b/tests/MemoTree.Tests/Storage/Hierarchy/CowNodeHierarchyStorageTests.cs
@@ -32,9 +32,11 @@ namespace MemoTree.Tests.Storage.Hierarchy {
             await storage.AddChildAsync(a, b);
 
             // attempt to create cycle: add A under B
-            await Assert.ThrowsAsync<InvalidOperationException>(async () => {
-                await storage.AddChildAsync(b, a);
-            });
+            await Assert.ThrowsAsync<InvalidOperationException>(
+                async () => {
+                    await storage.AddChildAsync(b, a);
+                }
+            );
         }
 
         [Fact]
@@ -50,9 +52,11 @@ namespace MemoTree.Tests.Storage.Hierarchy {
             await storage.AddChildAsync(b, c);
 
             // move A under C would form a cycle A->B->C->A
-            await Assert.ThrowsAsync<InvalidOperationException>(async () => {
-                await storage.MoveNodeAsync(a, c);
-            });
+            await Assert.ThrowsAsync<InvalidOperationException>(
+                async () => {
+                    await storage.MoveNodeAsync(a, c);
+                }
+            );
         }
 
         public void Dispose() {
diff --git a/tests/MemoTree.Tests/Storage/ViewStateStorageErrorTests.cs b/tests/MemoTree.Tests/Storage/ViewStateStorageErrorTests.cs
index 439fcc4..6cebe5d 100644
--- a/tests/MemoTree.Tests/Storage/ViewStateStorageErrorTests.cs
+++ b/tests/MemoTree.Tests/Storage/ViewStateStorageErrorTests.cs
@@ -20,12 +20,14 @@ public class ViewStateStorageErrorTests {
         public string GetNodeDirectory(MemoTree.Core.Types.NodeId nodeId) => Path.Combine(GetCogNodesDirectory(), nodeId.Value);
         public string GetNodeMetadataPath(MemoTree.Core.Types.NodeId nodeId) => Path.Combine(GetNodeDirectory(nodeId), "metadata.yml");
         public string GetNodeContentPath(MemoTree.Core.Types.NodeId nodeId, MemoTree.Core.Types.LodLevel level)
-            => Path.Combine(GetNodeDirectory(nodeId), level switch {
-                MemoTree.Core.Types.LodLevel.Gist => "gist.md",
-                MemoTree.Core.Types.LodLevel.Summary => "summary.md",
-                MemoTree.Core.Types.LodLevel.Full => "full.md",
-                _ => "content.md"
-            });
+            => Path.Combine(
+                GetNodeDirectory(nodeId), level switch {
+                    MemoTree.Core.Types.LodLevel.Gist => "gist.md",
+                    MemoTree.Core.Types.LodLevel.Summary => "summary.md",
+                    MemoTree.Core.Types.LodLevel.Full => "full.md",
+                    _ => "content.md"
+                }
+            );
         public bool IsWorkspace(string? directory = null) => Directory.Exists(GetWorkspaceRoot());
         public bool IsLinkedWorkspace() => false;
         public string? GetLinkTarget() => null;
