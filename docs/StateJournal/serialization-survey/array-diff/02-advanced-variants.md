# 02 进阶变种：处理移动与噪声

在经典 Myers 算法基础上，面对更复杂的真实场景（如代码重构、UI 列表重排），我们衍生出了处理“移动”和提升人类可读性的高级算法。这对 Json-Array 的增量序列化尤为重要。

## 1. Patience Diff (耐心差分)

如果你在使用 Git 时觉得默认的 diff 很难看懂（因为大块代码匹配错位了），可以尝试 `git diff --patience`。

### 1.1 原理
Patience Diff 的核心策略与耐心排序（Pub game Patience）有关，步骤如下：
1. **寻找唯一公共元素**：找出所有既在 $A$ 出现一次，也在 $B$ 出现一次，且内容相同的行。这些行被称为 **“锚点” (Anchors)**。
2. **最长序列**：在这些锚点中，找到最长递增子序列（LCS）。
3. **递归处理**：锚点将文件切分成若干个小块，对每个小块递归使用 diff 算法。

### 1.2 优点
- **防止误匹配**：它优先匹配那些“独一无二”的行，这大大降低了像 `}` 或 `</div>` 这种频繁出现的行被错误匹配的概率。
- **更符合直觉**：生成的 Patch 通常更符合逻辑结构。

### 1.3 对 Json-Array 的启示
如果你的 Json 对象包含**唯一 ID**（例如 `uuid` 字段），Patience Diff 的思想简直是天作之合。你可以把 UUID 视为“唯一行”，先匹配 ID，从逻辑上锁定结构，再对比内容。

## 2. Heckel's Algorithm (Heckel 移动检测)

LCS 系列算法最大的痛点是无法理解 **Move (移动)**。Paul Heckel 在 1978 年提出了一种线性时间 $O(N)$ 的算法，专门解决此问题。

### 2.1 算法流程
Heckel 算法不依赖 LCS，而是基于 **Symbol Table (符号表)** 和 **Counter (计数器)**。

它分为五步（简化版）：
1. **第一次扫描 (New)**：遍历新列表 $B$，建立符号表（Map），记录每个元素出现的次数和在 $B$ 中的索引。
2. **第二次扫描 (Old)**：遍历旧列表 $A$，更新符号表中元素在 $A$ 的计数。
3. **识别特定匹配 (Unique Match)**：如果一个元素在 $A$ 和 $B$ 中计数都为 1（唯一），则它们直接匹配。记录对应关系 `OA[i] <-> NB[j]`。
4. **扩展匹配 (Expand)**：从已找到的匹配点向上下扩散。如果两个匹配点的邻居也相等，则它们也必然匹配。（类似拉链原理）。
5. **生成结果**：
   - 如果 $B[j]$ 已匹配 $A[i]$，检查 $i$ 是否紧跟在 $B[j-1]$ 对应的 $A$ 索引之后。
   - 如果不是，说明发生了 **Move**。
   - 如果 $B[j]$ 没匹配到任何 $A$，则是 **Insert**。
   - 如果 $A[i]$ 没被匹配，则是 **Delete**。

### 2.2 为什么适合 UI 和对象数组？
- **支持 Block Move**：它可以识别出一整块元素的移动。
- **线性时间**：完全避开了 LCS 的 $O(N^2)$ 或 $O(ND)$ 陷阱。
- **ID 友好**：如果有唯一 Key，Heckel 算法的准确率极高。

## 3. 线性空间优化 (Linear Space Myers)

标准的 Myers 算法需要 $O(N^2)$ 空间（或者至少 $O(D^2)$）来存储路径回溯信息。这在内存受限时很危险。

- **分治策略 (Divide and Conquer)**：
  类似于 Hirchsberg's Algorithm。我们不需要记下整个路径，只需要找到路径的**中点**。
  从 $(0,0)$ 正向搜索，和从 $(N,M)$ 反向搜索，当它们相遇时，就确定了中点。
  然后递归解决前半段和后半段。

这使得空间复杂度降为线性 $O(N)$，但在时间上只增加约一倍常数。对于通用库来说，这是必须实现的优化。
