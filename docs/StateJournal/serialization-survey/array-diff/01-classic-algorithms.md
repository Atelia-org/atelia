# 01 经典基础：从 LCS 到 Myers

在探索 JSON Array Diff 之前，我们必须理解处理序列差异的基石算法。无论是代码版本控制（Git）、文档比较工具，还是 React/Vue 的虚拟 DOM Diff，其核心思想往往殊途同归。

## 1. 问题定义

给出两个序列 $A$ 和 $B$（可以是文本行、字符，也可以是 JSON 对象），我们要找到一个**最短编辑脚本（Shortest Edit Script, SES）**，将 $A$ 转换为 $B$。

允许的操作通常是：
- **Delete (删除)**: 从 $A$ 中移除一个元素。
- **Insert (插入)**: 向 $A$ 中添加一个来自 $B$ 的元素。
- *(Keep / Match (保留/匹配): 元素相同，无需操作)*

这个问题等价于寻找 **最长公共子序列 (Longest Common Subsequence, LCS)**。
- $D = N + M - 2 \cdot L$
- 其中 $D$ 是编辑距离（Diff 的大小），$N, M$ 是两序列长度，$L$ 是 LCS 的长度。

要让 Diff 最小，就要让 LCS 最长。

## 2. 经典的动态规划 (O(NM))

最朴素的解法是动态规划。构建一个 $N \times M$ 的矩阵，计算所有可能性的代价。
- 虽然能保证找到最优解，但 $O(NM)$ 的时间和空间复杂度对于大文件或大数组来说是不可接受的。

## 3. Myers' Algorithm (Diff 领域的王者)

Eugene W. Myers 在 1986 年发表的算法彻底改变了这一领域。Git 默认使用的就是 Myers 算法（或其变体）。

### 3.1 核心思想：编辑图与对角线

Myers 将 Diff 问题转化为在一个网格图上寻找从 $(0,0)$ 到 $(N,M)$ 的最短路径。
- **x 轴** 代表序列 $A$。
- **y 轴** 代表序列 $B$。
- **向右走** ($x+1$) 代表删除（Delete）。
- **向下走** ($y+1$) 代表插入（Insert）。
- **对角线走** ($x+1, y+1$) 代表匹配（Keep），代价为 0，只能在 $A[x] == B[y]$ 时发生。

问题变成了：如何用最少的“向右”或“向下”步数，结合尽可能多的“对角线”步数，到达终点。

### 3.2 贪心策略

Myers 算法发现了一个关键性质：
> 如果存在一个编辑距离为 $D$ 的路径，我们总能在包含所有编辑距离为 $D-1$ 的路径端点的基础上，通过一步操作找到它。

算法通过迭代 $D$（编辑距离）来进行搜索：
- $D=0$: 纯匹配。
- $D=1$: 1个插入或1个删除 + 任意匹配。
- ...

它在“对角线索引” $k = x - y$ 上进行动态规划。
只需维护每条对角线 $k$ 上目前能到达的最远 $x$ 坐标。

### 3.3 复杂度分析

时间复杂度为 $O(ND)$，其中 $D$ 是差异的大小。
- **最好情况**：两个序列完全相同，$D=0$，复杂度 $O(N)$。
- **最坏情况**：两个序列完全不同，$D = N+M$，复杂度 $O((N+M)^2)$。
- **平均情况**：通常差异较小，因此远快于 $O(NM)$。

### 3.4 对于 Json-Array 的启示

Myers 算法非常适合用来处理**有序列表**的增量更新。如果你的 Json Array 很大，但变化很小（例如用户在一个长列表中插入了一项），Myers 能迅速定位到修改点，生成极小的 Patch。

然而，Myers 也有弱点：
1. **移动 (Move) 识别困难**：如果把数组第一项移到最后，Myers 会将其视为“删除第一个” + “在最后插入一个相同的”。对于序列化来说，这可能导致不必要的数据传输。
2. **对重复元素敏感**：如果数组中有大量相同的数字或对象，Myers 可能会产生非直观的匹配结果（虽然数学上是最优的）。

---

**总结**：
如果你的 Json Array 主要操作是插入和删除，且元素顺序相对稳定，Myers 是最佳的默认选择。可以通过 C# 的 `Span<T>` 做高性能实现。
