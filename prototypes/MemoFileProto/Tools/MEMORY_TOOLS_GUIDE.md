# Memory Editing Tools - 设计指南

本文档说明 MemoFileProto 中的两个记忆编辑工具的设计理念、使用场景和最佳实践。

## 设计理念

### 为什么拆分成两个工具？

1. **意图明确化**：工具名称本身就声明了编辑的复杂度和风险级别
2. **参数验证清晰**：避免复杂的参数组合逻辑
3. **错误信息针对性强**：失败时可以直接指导使用者切换到合适的工具
4. **符合"渐进式复杂度"原则**：90% 的简单场景用简单工具，10% 的复杂场景用高级工具
5. **独立演进**：未来可以独立扩展各工具的功能，互不影响

---

## 工具一：`memo_replace_literal `

### 定位
**简单直接的文本替换工具**，适用于要替换的内容在记忆中"唯一存在"的场景。

### 参数

```json
{
  "old_text": "要替换的旧文本（必须精确匹配）",
  "new_text": "替换后的新文本"
}
```

### 使用场景

#### ✅ 适合的场景

1. **修改唯一的状态标记**
  ```json
  {
    "old_text": "项目状态：进行中",
    "new_text": "项目状态：已完成"
  }
  ```

2. **删除唯一的 TODO 标记**
  ```json
  {
    "old_text": "TODO: 补充技术栈说明",
    "new_text": ""
  }
  ```

3. **追加新内容**（old_text 为空）
  ```json
  {
    "old_text": "",
    "new_text": "\n## 新章节\n内容..."
  }
  ```

#### ❌ 不适合的场景

1. **内容出现多次**：会报错并提示使用 `memo_replace_span`
2. **担心格式问题**（空格/Tab 混淆）：建议用 `memo_replace_span` 的区域锚定

### 行为特性

- **唯一性检查**：如果 `old_text` 出现多次，操作会失败
- **单次替换**：即使唯一匹配，也只替换首次出现的位置
- **换行符归一化**：所有输入和记忆内容统一转换为 `\n`
- **友好的错误提示**：
  - 找不到匹配：显示当前记忆全文
  - 多个匹配：显示匹配位置和上下文，提示使用 `memo_replace_span`

---

## 工具二：`memo_replace_span`

### 定位
**精确定位的区域替换工具**，适用于需要上下文锚定的复杂编辑场景。

### 参数

```json
{
  "old_span_start": "区域起始标记（必需）",
  "old_span_end": "区域结束标记（必需）",
  "new_text": "新内容（包含标记本身）",
  "search_after": "在此文本之后开始搜索 old_span_start（可选）"
}
```

### 使用场景

#### ✅ 场景 1：修改特定章节（内容出现多次）

假设记忆中有多个 `### 技术栈` 章节，但你只想修改 2024 年总结下的那个：

```json
{
  "search_after": "## 2024年总结",
  "old_span_start": "### 技术栈",
  "old_span_end": "### 团队协作",
  "new_text": "### 技术栈\n主要使用 Rust 和 TypeScript，全面迁移到异步架构。"
}
```

**行为**：
1. 先找到 `## 2024年总结`
2. 在其后查找 `### 技术栈`
3. 再找到 `### 团队协作`
4. 替换两个标记之间的内容（不包含标记本身）

#### ✅ 场景 2：避免完整复述大段落

假设你要修改一个 500 字段落中的 20 字，完整复述很浪费 token：

```json
{
  "old_span_start": "关于项目进度：",
  "old_span_end": "预计完成时间",
  "new_text": "关于项目进度：已完成 80%，剩余核心功能开发中。"
}
```

**Token 节省**：只需要复述首尾标记（~10 token），而不是整段（~500 token）

#### ✅ 场景 3：替换包含标记的整个块

```json
{
  "old_span_start": "<!-- BEGIN DEPRECATED -->",
  "old_span_end": "<!-- END DEPRECATED -->",
  "new_text": "<!-- UPDATED SECTION -->\n新的实现方案\n<!-- END UPDATED -->"
}
```

**行为**：连同标记本身一起被替换。

### 行为特性

- **上下文定位**：可选提供 `search_after` 将搜索起点锚定在指定文本之后，以在多个同名区域中精确命中目标
- **灵活的标记处理**：默认保留标记，可选替换标记
- **容错性**：如果标记不匹配，会显示详细的上下文帮助调试
- **不强制唯一性**：即使区域出现多次，只要你提供的上下文能定位到其中一个，就允许操作

---

## 设计细节与权衡

### 1. 换行符归一化

**决策**：所有输入和记忆内容统一转换为 `\n`

**理由**：
- LLM 很难准确感知 `\r\n` vs `\n`
- 避免跨平台格式问题
- 简化匹配逻辑

### 2. 唯一性检查的策略

| 工具 | 策略 |
|------|------|
| `memo_replace_literal ` | **强制唯一**：多个匹配时失败 |
| `memo_replace_span` | **允许多个**：通过上下文定位其中一个 |

**理由**：
- 简单工具应该保守，避免意外批量修改
- 复杂工具赋予用户精确控制的能力

### 3. 错误信息设计

两个工具的错误信息都包含：
- ✅ 清晰的问题描述
- ✅ 相关的上下文片段
- ✅ 建议的下一步行动

示例：
```
Error: 找到多个匹配项（至少在位置 42 和 156）。

此工具仅支持唯一匹配。请改用 memo_replace_span 工具，并配合 `search_after` 参数或更精确的标记来定位。

第一处匹配的上下文：
...技术栈：主要使用 Python...
```

### 4. Token 成本对比

假设要修改一个 500 字符段落中的 20 字符：

| 方案 | Input Tokens | 说明 |
|------|-------------|------|
| `memo_replace_literal ` 完整复述 | ~500 | 需要完整复述整段 |
| `memo_replace_span` 首尾锚定 | ~30 | 仅需复述首尾标记 |
| **Token 节省** | **94%** | 长期收益巨大 |

---

## 最佳实践

### 对于 LLM Agent

1. **优先尝试简单工具**
   ```
   memo_replace_literal  → 失败(多匹配) → memo_replace_span
   ```

2. **选择好的锚点**
   - ✅ 使用稳定的标题、标记、关键词作为锚点
   - ❌ 不要用容易变化的时间戳、版本号作为锚点

3. **合理使用上下文**
  - 仅在需要 disambiguation 时传入 `search_after`
  - 上下文应该"恰好够用"，不要太长也不要太短（一般 20-50 字符）

### 对于工具集成者

1. **记忆文档的结构化**
   - 使用清晰的章节标题（`##`, `###`）
   - 使用 HTML 注释作为隐式标记（`<!-- section:xxx -->`）
   - 避免大段无结构的文本

2. **版本控制**
   - 建议在文件系统层面对记忆文件做版本控制（Git）
   - 工具本身不提供"撤销"功能，依赖外部备份机制

3. **并发控制**
   - 当前实现假设单线程访问（专有记忆）
   - 如果需要多 Agent 共享，应在更高层实现锁机制

---

## 未来扩展方向

### 短期可能的改进

1. **`MemoReplaceSpan` 增加正则支持**
  ```json
  {
    "old_span_start_regex": "^### 技术栈.*$",
    "old_span_end": "### 团队"
  }
  ```

2. **返回 Diff 信息**
   - 不仅返回新内容，还显示具体改了哪些行

3. **批量操作工具**（谨慎）
   - `update_all_occurrences`：全局替换所有匹配
   - 需要更严格的安全检查

### 长期可能的方向

1. **语义搜索锚定**
   - 不用精确文本，用语义描述：`"找到讲 Rust 性能优化的那段"`

2. **结构化记忆后端**
   - 从纯文本迁移到 JSON/YAML/Markdown AST
   - 提供更强大的查询和修改能力

3. **冲突检测（乐观锁）**
   - 即使是专有访问，也可能遇到"思考时"和"执行时"状态不一致
   - 可选的 `last_read_hash` 参数

---

## 总结

| 特性 | `memo_replace_literal ` | `memo_replace_span` |
|------|-------------------|---------------------|
| **复杂度** | 简单 | 高级 |
| **参数数量** | 2 个必需 | 3 个必需 + 3 个可选 |
| **唯一性要求** | 强制 | 不强制 |
| **Token 成本** | 高（完整复述）| 低（首尾锚定）|
| **适用场景** | 90% 简单编辑 | 10% 复杂编辑 |
| **错误恢复** | 切换到 region 工具 | 调整上下文 |

**核心设计哲学**：
> "做好一件事，并提供清晰的升级路径"

这种设计让 LLM Agent 能够：
- 在简单场景下快速完成任务（低认知负担）
- 在复杂场景下精确控制编辑（高表达能力）
- 通过错误信息学习何时升级工具（自我改进）
